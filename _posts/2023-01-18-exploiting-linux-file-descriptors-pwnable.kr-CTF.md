---
tags: reverse-engineering
category: CTF
---

# Description

This is an extremely easy beginner level challenge taken from https://pwnable.kr/play.php

We are given the following 3 files:

![task](images/ctf_images/fd1.png)

Task is to read the `flag` file.

# Solution

* Trying the obvious `cat flag` results in `Permission denied`
* Verifying the permission `ls -l flag`:
	```bash
	-r--r----- 1 fd_pwn root 50 Jun 11  2014 flag
	```
* Our user does not have the read permission. Let's try to run the binary `./fd`

![fd2](images/ctf_images/fd2.png)

* It looks like the program expects a number arguement:

![fd3](images/ctf_images/fd3.png)

* Trying to read the source code `fd.c` to understand what's going on:

```bash
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
char buf[32];
int main(int argc, char* argv[], char* envp[]){
	if(argc<2){
		printf("pass argv[1] a number\n");
		return 0;
	}
	int fd = atoi( argv[1] ) - 0x1234;
	int len = 0;
	len = read(fd, buf, 32);
	if(!strcmp("LETMEWIN\n", buf)){
		printf("good job :)\n");
		system("/bin/cat flag");
		exit(0);
	}
	printf("learn about Linux file IO\n");
	return 0;

}
```

* My observations reading the above source code:
	* We have to get the program to execute the line `system("/bin/cat flag");` - i.e., the condition `if(!strcmp("LETMEWIN\n", buf))` must return `true`
	* For the above condition to return `true`, the value of `buf` must be `LETMEWIN\n`
	* The only input that the progam accepts is `argv[1]`, which is used to calculate `fd` (file descriptor) on line 10.
	* `len = read(fd, buf, 32);` - This line reads up to 32 bytes of data from `fd` and stores the result in `buf`. So using our input (`argv[1]`) we can control `fd`, and using `fd` we can control `buf`. Please remember that we can not directly pass `LETMEWIN\n` inside `fd` as it's of type `int`, nor we can pass this string into `argv[1]` as it gets converted to int anyways.
	* In Linux, `fd=0` is assigned to `stdin`. i.e., when we call `read(0, buf, 32)` the program instructs the OS to read up to 32 bytes of data from the standard input stream. If we can get the program to execute above instruction, we can essentially control the value of `buf` via stdin.
	* What must be the value of our input `(argv[1])`, so that `fd` becomes 0? The answer is in line 10 - `int fd = atoi( argv[1] ) - 0x1234;` `0x1234` is a hexadecimal value and we have to calculate the decimal equivalent of this which is `4660`.

* Running `./fd 4660` lets us enter another input via stdin. We then enter `LETMEWIN\n` to get the contents of our flag file:

![fd4](images/ctf_images/fd4.png)